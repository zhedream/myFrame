<div id="output"></div>
<!-- 加载 Babel -->
<!-- <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script> -->
<!-- 你的脚本代码 -->
<!-- <script type="text/babel"> -->
<script>
// https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499763408e24c210985d34edcabbca944b4239e20000
// http://www.cnblogs.com/smoothLily/p/4745856.html  参
// https://www.jianshu.com/p/80bcf8b2004e


var A = function () {};
var B ={};

// console.log(A.__proto__)
// console.log(A.__proto__.__proto__)
// console.log(B.__proto__)

//
// console.log(A.prototype)
// console.log(B.prototype)

// 
Array.prototype.test = function (){
    console.log('Array原型对象 的自定义 test 方法');
    
}
Object.prototype.test1 = function(){
    console.log('Object原型对象 的自定义 test1 方法');
}
// 本身 是一个原型(对象?)  隐式 指向  Arrayy
var arr = [1,2,3,{test3:()=>{console.log('arr 的自定义 test3 方法')}}];   // arr -> Array.prototype (Arr隐式原型/父类) -> Object.prototype (Array的原型对象/父类) -> null

arr.test();
arr.test1();

var a = [4,5];
a.__proto__ = arr; // 强制把原型 指向  arr
a[3]['test3'](); // 原型对象 的 第三个属性(对象),中的 test3 方法

//
function boy(name){
    this.name = name

    this.run = function(){
        console.log(this.name+"runing");
        
    }
}
var xiaoming = new boy('小明');

// prototype 理解为 公共的对象 用于 存储 公共的 属性/方法
// 只有函数function才具有prototype属性。这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法
boy.prototype.fly = function(){
    console.log(this.name+"flying");
    
}

console.log('xiaoming',xiaoming);
console.log('xiaoming.prototype',xiaoming.prototype);

console.log('a',a);
console.log('a.prototype',a.prototype);   //  __proto__   &  prototype   ???   函数 才有 prototype ?? 
console.log('a.prototype',a.__proto__);   //  __proto__   &  prototype   ???   js里所有的对象都有proto属性(对象，函数)，指向构造该对象的构造函数的原型。

console.log('arr->',arr);
console.log('arr.prototype->',arr.prototype);  // 隐式指向  Arrayy   所以 为空?    new  的 不为空??

console.log('Array->',Array);
console.log('Array.prototype->',Array.prototype);

console.log('Object->',Object);
console.log('Object.prototype->',Object.prototype);

// 0.Object.prototype的__proto__属性指向null。
// 1.对象有属性__proto__,指向该对象的构造函数的原型对象。
// 2.方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。



</script>