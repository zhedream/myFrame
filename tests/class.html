<div id="output"></div>
<!-- 加载 Babel -->
<!-- <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script> -->
<!-- 你的脚本代码 -->
<!-- <script type="text/babel"> -->
<script>
    // https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499763408e24c210985d34edcabbca944b4239e20000
    // http://www.cnblogs.com/smoothLily/p/4745856.html  参
    // https://www.jianshu.com/p/80bcf8b2004e


    var A = function () { };
    var B = {};

    // console.log(A.__proto__)
    // console.log(A.__proto__.__proto__)
    // console.log(B.__proto__)
    // console.log(A.prototype)
    // console.log(B.prototype)

    // 
    Array.prototype.test = function () {
        console.log('Array原型对象 的自定义 test 方法');

    }
    Object.prototype.test1 = function () {
        console.log('Object原型对象 的自定义 test1 方法');
    }
    // 本身 是一个原型(对象?)  隐式 指向  Arrayy
    var arr = [1, 2, 3, { test3: () => { console.log('arr 的自定义 test3 方法') } }];   // arr -> Array.prototype (Arr隐式原型/父类) -> Object.prototype (Array的原型对象/父类) -> null

    arr.test();
    arr.test1();

    var a = [4, 5];
    a.__proto__ = arr; // 强制把原型 指向  arr
    a[3]['test3'](); // 原型对象 的 第三个属性(对象),中的 test3 方法

    // --------
    function boy(name) {
        this.name = name

        this.run = function () {
            console.log(this.name + "runing");

        }
    }
    var xiaoming = new boy('小明');




    // boy.prototype指向的对象就是xiaoming、xiaohong的原型对象
    // prototype 理解为 公共的对象 用于 存储 公共的 属性/方法
    // 只有函数function才具有prototype属性。这个属性是一个指针，指向一个对象(原型对象)，这个对象的用途就是包含所有实例共享的属性和方法  
    // 原型对象 特殊的 独立出来的 对象 boy.prototype  抽象类  <<--  构造函数
    // __proto__ 继承 自哪里
    boy.prototype.fly = function () {
        console.log(this.name + "flying");

    }

    console.log('xiaoming', xiaoming);
    console.log('xiaoming.prototype', xiaoming.constructor);
    console.log('xiaoming.prototype', xiaoming.__proto__.constructor);

    console.log('boy', boy);
    console.log('boy.prototype', boy.constructor);

    // 理解部分
    xiaoming.constructor === boy.prototype.constructor; // true
    boy.prototype.constructor === boy; // true
    Object.getPrototypeOf(xiaoming) === boy.prototype; // true
    xiaoming instanceof boy; // true


    // --------

    console.log('a', a);
    console.log('a.prototype', a.prototype);   //  __proto__   &  prototype   ???   函数 才有 prototype ?? 
    console.log('a.prototype', a.__proto__);   //  __proto__   &  prototype   ???   js里所有的对象都有proto属性(对象，函数)，指向构造该对象的构造函数的原型。

    console.log('arr->', arr);
    console.log('arr.prototype->', arr.prototype);  // 隐式指向  Arrayy   所以 为空 

    console.log('Array->', Array);
    console.log('Array.prototype->', Array.prototype);

    console.log('Object->', Object);
    console.log('Object.prototype->', Object.prototype);

    // 0.Object.prototype的__proto__属性指向null。
    // 1.对象有属性__proto__,指向该对象的构造函数的原型对象。
    // 2.方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。



// ------------------------------------------- 华丽分割线

    // 实现 继承 extends
    function inherits(Child, Parent) {
        var F = function () { };
        F.prototype = Parent.prototype;
        Child.prototype = new F();
        Child.prototype.constructor = Child;
    }
    // class Student 的 构造函数
    function Student(props) {
        this.name = props.name || 'Unnamed';
    }
    // 伪静态  公共方法  原型对象?
    Student.prototype.hello = function () {
        alert('Hello, ' + this.name + '!');
    }

    // class PrimaryStudent 的 构造函数
    function PrimaryStudent(props) {
        Student.call(this, props); // 调用 
        this.grade = props.grade || 1;
    }
    // 绑定其他方法到PrimaryStudent原型:
    PrimaryStudent.prototype.getGrade = function () {
        return this.grade;
    };

    // 实现原型继承链:
    inherits(PrimaryStudent, Student);

    var man = new PrimaryStudent('man');

    console.log('man', man);
    console.log('man', man.__proto__);

// ----------------------------------------------  华丽分割线
    class Boy {
        constructor(name, action,fn) {
            this.name = name;
            // for 对象
            eval("this." + action + "=" + fn) // 实例方法
        }

        // 实例的公共方法  // 区别与 php  的类公共静态 方法
        say() {
            console.log('Hello, ' + this.name + '!');
        }
        go() {
            console.log('Hello, ' + this.name + '!');
        }
    }

    // 外部重写 原型对象的 say 方法
    Boy.prototype.say = function () {
        console.log('重写say');
    }


    var a = new Boy('小明', 'go',function(){console.log('GO覆盖原型公共 go')})
    var b = new Boy('小B', 'go1',function(){console.log('GO1没覆盖原型公共 go')})

    // a.__proto__.go();
    a.go()
    a.say();
    b.go()
    b.say();

    console.log(a);


</script>